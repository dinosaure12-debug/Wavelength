<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<title>Wavelength – Mobile (Multi Sync)</title>

<style>
:root{
  --bg:#0b1220;
  --panel:rgba(255,255,255,.06);
  --border:rgba(255,255,255,.14);
  --text:#f9fafb;
  --muted:rgba(255,255,255,.70);
  --accent:#f97316;

  --green:#22c55e;
  --orange:#f59e0b;
  --red:#ef4444;
}

*{box-sizing:border-box}

body{
  margin:0;
  font-family: Arial, sans-serif;
  background:
    radial-gradient(900px 500px at 20% 0%, rgba(249,115,22,.12), transparent 60%),
    radial-gradient(900px 500px at 80% 10%, rgba(59,130,246,.10), transparent 60%),
    var(--bg);
  color: var(--text);
  padding: 12px;
  display:flex;
  justify-content:center;
}

.app{
  width: min(820px, 100%);
  display:flex;
  flex-direction:column;
  gap:12px;
}

.panel{
  background: var(--panel);
  border:1px solid var(--border);
  border-radius:16px;
  padding:14px;
}

.turn{
  text-align:center;
  font-size:26px;
  font-weight:900;
  letter-spacing:.2px;
}

.subturn{
  text-align:center;
  font-size:14px;
  color: var(--muted);
  margin-top:6px;
}

.pair{
  display:flex;
  justify-content:center;
  gap:12px;
  flex-wrap:wrap;
  align-items:center;
  font-weight:900;
  font-size:18px;
}

.pill{
  padding: 8px 14px;
  border-radius:999px;
  background: rgba(255,255,255,.08);
  border: 1px solid var(--border);
  min-width: 220px;
  text-align:center;
}

canvas{
  width: 100%;
  max-width: 620px;
  margin: auto;
  display:block;
  border-radius: 18px;
  background: rgba(0,0,0,.18);
  border:1px solid var(--border);
  touch-action:none;
}

.controls{
  text-align:center;
  display:flex;
  justify-content:center;
  gap:10px;
  flex-wrap:wrap;
}

button{
  padding: 12px 18px;
  border-radius: 999px;
  border: 1px solid var(--border);
  background: rgba(0,0,0,.18);
  color: var(--text);
  font-weight: 900;
  cursor: pointer;
}

button.primary{
  background: linear-gradient(180deg, #f97316, #fb923c);
  color: #111;
  border-color: rgba(249,115,22,.55);
}

button.ghost{ background: rgba(255,255,255,.06); }

.hidden{ display:none; }

.scoreline{
  display:flex;
  justify-content:space-between;
  align-items:center;
  padding: 10px 12px;
  border-radius: 12px;
  border: 1px solid var(--border);
  background: rgba(0,0,0,.16);
  gap:10px;
}

.scoreLeft{
  display:flex;
  align-items:center;
  gap:10px;
  min-width: 0;
}
.colorDot{
  width: 12px;
  height: 12px;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,.18);
  flex: 0 0 auto;
}
.nameText{
  font-weight:900;
  overflow:hidden;
  text-overflow:ellipsis;
  white-space:nowrap;
}
.scorePts{ font-weight:950; color: rgba(255,255,255,.90); }

.sliderWrap{
  max-width: 620px;
  margin: 12px auto 0 auto;
  padding: 10px 12px;
  border-radius: 14px;
  border: 1px solid var(--border);
  background: rgba(0,0,0,.14);
}
.sliderTop{
  display:flex;
  justify-content:space-between;
  align-items:center;
  gap:10px;
  margin-bottom:8px;
}
.badge{
  padding: 6px 10px;
  border-radius: 999px;
  border: 1px solid var(--border);
  background: rgba(255,255,255,.06);
  font-size: 12px;
  font-weight: 900;
  color: rgba(255,255,255,.86);
}
input[type="range"]{ width:100%; accent-color: var(--accent); }

.legend{
  display:flex;
  flex-wrap:wrap;
  gap:10px;
  margin-top:10px;
  font-size:12px;
  color: rgba(255,255,255,.78);
}
.dot{
  display:inline-block;
  width:10px;
  height:10px;
  border-radius: 999px;
  margin-right:6px;
  vertical-align:middle;
}

.revealNote{
  max-width: 620px;
  margin: 10px auto 0 auto;
  font-size: 12px;
  color: rgba(255,255,255,.75);
  text-align:center;
}

/* ===== Modals ===== */
.overlay{
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,.62);
  backdrop-filter: blur(8px);
  display:none;
  align-items:center;
  justify-content:center;
  padding: 14px;
  z-index: 9999;
}
.overlay.show{ display:flex; }

.modal{
  width: min(760px, 100%);
  border-radius: 18px;
  border: 1px solid rgba(255,255,255,.12);
  background:
    radial-gradient(900px 520px at 15% 0%, rgba(249,115,22,.10), transparent 55%),
    radial-gradient(900px 520px at 85% 15%, rgba(59,130,246,.10), transparent 55%),
    rgba(12,18,34,.94);
  padding: 16px;
  display:flex;
  flex-direction:column;
  gap:12px;
}

.modal h2{ margin:0; font-size:18px; }
.small{ font-size:12px; color: rgba(255,255,255,.70); }

.row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }

.field{
  display:flex;
  flex-direction:column;
  gap:6px;
  flex:1;
  min-width: 160px;
}
label{ font-size:12px; color: rgba(255,255,255,.78); font-weight:900; }

select, input[type="text"]{
  padding: 10px 12px;
  border-radius: 12px;
  border: 1px solid rgba(255,255,255,.12);
  background: rgba(0,0,0,.20);
  color: var(--text);
  outline:none;
  font-size: 13px;
}
select:focus, input[type="text"]:focus{
  border-color: rgba(249,115,22,.55);
  box-shadow: 0 0 0 3px rgba(249,115,22,.12);
}

.playersList{
  display:flex;
  flex-direction:column;
  gap:10px;
  max-height: 48vh;
  overflow:auto;
  padding-right:4px;
}

.playerRow{
  display:flex;
  gap:10px;
  align-items:center;
}
.playerRow input{ flex:1; }
.colorPreview{
  width: 16px; height:16px; border-radius:999px;
  border: 1px solid rgba(255,255,255,.18);
}
</style>
</head>

<body>
<div class="app">

  <div class="panel">
    <div class="turn" id="turnTitle">Wavelength</div>
    <div class="subturn" id="turnSub">Crée une room ou rejoins avec un code.</div>
  </div>

  <div class="panel">
    <div class="pair" id="pair"></div>
  </div>

  <div id="errBox" class="panel hidden"
       style="border:2px solid rgba(255,0,0,.5); background:rgba(255,0,0,.08); color:#fff;">
    <b>Erreur JS</b>
  </div>

  <div class="panel">
    <canvas id="canvas" width="900" height="520"></canvas>

    <div id="sliderWrap" class="sliderWrap hidden">
      <div class="sliderTop">
        <div class="badge">Réglage précis</div>
        <div class="badge">Valeur : <span id="sliderVal">50</span></div>
      </div>
      <input id="needleSlider" type="range" min="0" max="100" step="1" value="50" />
    </div>

    <div id="legendWrap" class="legend hidden" style="max-width:620px; margin:10px auto 0 auto;">
      <span><span class="dot" style="background:var(--green)"></span>Vert ±5 = 4 pts</span>
      <span><span class="dot" style="background:var(--orange)"></span>Orange ±7 = 2 pts</span>
      <span><span class="dot" style="background:var(--red)"></span>Rouge ±11 = 1 pt</span>
    </div>
    <div id="revealNote" class="revealNote hidden">
      Barre blanche épaisse = Psychic. Barres fines = joueurs (couleurs choisies).
    </div>
  </div>

  <div class="panel controls">
    <button id="btnSettings" class="ghost">Paramètres</button>
    <button id="actionBtn" class="primary">—</button>
  </div>

  <!-- ===== MULTI PANEL ===== -->
  <div class="panel">
    <div style="font-weight:950; font-size:16px; margin-bottom:10px;">Multijoueur</div>

    <div class="row" style="gap:10px;">
      <button id="btnHost" class="primary" style="flex:1;">Créer une room</button>
      <button id="btnJoin" class="ghost" style="flex:1;">Rejoindre</button>
    </div>

    <div id="multiBox" style="margin-top:12px;" class="hidden">
      <div class="row">
        <div class="field">
          <label>Code room</label>
          <input id="roomCodeInput" type="text" placeholder="ABCD" maxlength="4" />
        </div>
        <div class="field">
          <label>Pseudo</label>
          <input id="playerNameInput" type="text" placeholder="Ton pseudo" maxlength="14" />
        </div>
      </div>
      <div class="row" style="justify-content:flex-end;">
        <button id="btnConfirmJoin" class="primary">OK</button>
      </div>
      <div class="small" style="margin-top:6px;">Le code fait 4 caractères (majuscules).</div>
    </div>

    <div id="roomInfo" class="hidden" style="margin-top:12px;">
      <div class="badge">Room : <b id="roomCodeLabel">----</b></div>
      <div class="small" style="margin-top:8px;">Joueurs connectés :</div>
      <div id="lobbyPlayers" style="margin-top:8px; display:flex; flex-direction:column; gap:8px;"></div>

      <div class="small" style="margin-top:10px;">
        Statut : <b id="roomStatusLabel">—</b>
      </div>
      <div class="small" style="margin-top:6px;" id="roleLabel">—</div>
    </div>
  </div>

  <div class="panel" id="scoresPanel">
    <div style="display:flex; justify-content:space-between; align-items:center; gap:10px; flex-wrap:wrap;">
      <div style="font-weight:950; font-size:16px;">Scores (room)</div>
      <button id="btnResetScores" class="ghost">Reset scores</button>
    </div>
    <div id="scores" style="margin-top:10px; display:flex; flex-direction:column; gap:8px;"></div>
  </div>

</div>

<!-- ===== Settings overlay ===== -->
<div id="settingsOverlay" class="overlay">
  <div class="modal">
    <div class="row" style="justify-content:space-between;">
      <div>
        <h2>Paramètres</h2>
        <div class="small">Choisis les packs de catégories utilisés pour tirer une catégorie.</div>
      </div>
      <button id="btnCloseSettings" class="ghost">Fermer</button>
    </div>

    <div class="row">
      <div class="field">
        <label>Points pour gagner</label>
        <input id="pointsToWinInput" type="text" inputmode="numeric" placeholder="ex : 20" />
        <div class="small">Le premier qui atteint ce total gagne.</div>
      </div>
    </div>

    <div id="packsList" class="playersList"></div>

    <div class="row" style="justify-content:flex-end;">
      <button id="btnSelectAll" class="ghost">Tout cocher</button>
      <button id="btnSelectNone" class="ghost">Tout décocher</button>
      <button id="btnSaveSettings" class="primary">Enregistrer</button>
    </div>
  </div>
</div>

<!-- ===== Winner overlay ===== -->
<div id="winnerOverlay" class="overlay">
  <div class="modal">
    <div class="row" style="justify-content:space-between;">
      <div>
        <h2 id="winnerTitle">Victoire</h2>
        <div class="small" id="winnerSub">Bravo !</div>
      </div>
      <button id="btnCloseWinner" class="ghost">Fermer</button>
    </div>
    <div class="row" style="justify-content:flex-end;">
      <button id="btnContinue" class="primary">OK</button>
    </div>
  </div>
</div>

<script type="module">
/* ================= DEBUG MOBILE ================= */
window.addEventListener("error", function (e) {
  const box = document.getElementById("errBox");
  if (!box) return;
  box.classList.remove("hidden");
  box.innerHTML = `
    <b>Erreur JavaScript</b><br>
    ${e.message}<br>
    <small>${e.filename}:${e.lineno}</small>
  `;
});
window.addEventListener("unhandledrejection", function (e) {
  const box = document.getElementById("errBox");
  if (!box) return;
  box.classList.remove("hidden");
  box.innerHTML = `
    <b>Promise rejetée</b><br>
    ${String(e.reason)}
  `;
});

/* ================= FIREBASE (CDN) ================= */
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-app.js";
import {
  getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot
} from "https://www.gstatic.com/firebasejs/10.12.5/firebase-firestore.js";

/* ======= TON CONFIG FIREBASE ======= */
const firebaseConfig = {
  apiKey: "AIzaSyB2bxTrr3nT_p20hEp7j2DFR3ptWtDPXP4",
  authDomain: "wavelength-3728d.firebaseapp.com",
  projectId: "wavelength-3728d",
  storageBucket: "wavelength-3728d.firebasestorage.app",
  messagingSenderId: "1045281881502",
  appId: "1:1045281881502:web:fafcfa708554d5564e6a8f"
};

const app = initializeApp(firebaseConfig);
const db = getFirestore(app);

/* ===================== CATEGORY PACKS ===================== */
const CATEGORY_PACKS = {
  table: { label:"Autour de la table", items:[
    "quelqu’un de radin","quelqu’un de drôle","quelqu’un de susceptible","quelqu’un d’organisé",
    "quelqu’un de retardataire","quelqu’un de chill","quelqu’un de compétitif","quelqu’un de têtu",
    "quelqu’un de diplomate","quelqu’un de bordélique","quelqu’un de chanceux","quelqu’un de malchanceux"
  ]},
  objets: { label:"Objets", items:[
    "un objet de cuisine","un gadget","un truc qui fait du bruit","un objet de daron",
    "une chaussure","une voiture","une console","un moyen de locomotion","un objet dangereux"
  ]},
  bouffe: { label:"Bouffe", items:["un truc pour une raclette","un fromage","un burger","un plat","un dessert","une boisson","une viennoiserie","un truc de fête"]},
  pop: { label:"Pop culture", items:["un rappeur","un acteur","un mème","un jeu vidéo","un streamer","une série","un anime","un super-héros","un clip","un banger","un blockbuster","un sportif","un auteur","un politique","un influenceur"]},
  lieux: { label:"Lieux", items:["un aéroport","une plage","un camping","un centre commercial","un métro","un stade","une boîte de nuit","un pays"]},
  marques: { label:"Marques", items:["une marque de streetwear","une marque de téléphone","une marque de voiture","un studio de jeu vidéo","une marque tech","une marque de boisson"]},
  metiers: { label:"Jobs et vie adulte", items:["un métier","un type de collègue","un type de client","un type de patron","une paye"]},
  internet: { label:"Réseaux sociaux et internet", items:["une appli","un réseau social","une trend","une notification","une vidéo YouTube"]},
  delires: { label:"Délires et situations absurdes", items:["un super-pouvoir","une catastrophe","une peur","un truc illégal"]}
};

/* ===================== COLORS ===================== */
const COLOR_CHOICES = [
  {label:"Bleu électrique", value:"#2979FF"},
  {label:"Cyan néon",       value:"#00E5FF"},
  {label:"Vert néon",       value:"#A3FF12"},
  {label:"Jaune punchy",    value:"#FFD400"},
  {label:"Orange vif",      value:"#FF6B00"},
  {label:"Rouge néon",      value:"#FF1744"},
  {label:"Rose néon",       value:"#FF2D95"},
  {label:"Violet pop",      value:"#7C4DFF"},
];

/* ===================== SCORING ===================== */
const Z_GREEN  = 5;   // ±5 -> 4 pts
const Z_ORANGE = 7;   // ±7 -> 2 pts
const Z_RED    = 11;  // ±11 -> 1 pt
function pointsForGuess(secret, guess){
  const d = Math.abs(guess - secret);
  if(d <= Z_GREEN) return 4;
  if(d <= Z_ORANGE) return 2;
  if(d <= Z_RED) return 1;
  return 0;
}

/* ===================== SETTINGS (LOCAL) ===================== */
const SETTINGS_KEY = "wl_mobile_settings_v2";
let settings = { pointsToWin: 20, packsEnabled: {} };

function saveSettings(){ localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings)); }
function loadSettings(){
  try{
    const raw = localStorage.getItem(SETTINGS_KEY);
    if(!raw){
      settings.packsEnabled = Object.fromEntries(Object.keys(CATEGORY_PACKS).map(k=>[k,true]));
      return;
    }
    const data = JSON.parse(raw);
    if(typeof data.pointsToWin === "number") settings.pointsToWin = data.pointsToWin;
    if(data.packsEnabled && typeof data.packsEnabled === "object") settings.packsEnabled = data.packsEnabled;
    for(const k of Object.keys(CATEGORY_PACKS)){
      if(settings.packsEnabled[k] == null) settings.packsEnabled[k] = true;
    }
  }catch(e){
    settings.packsEnabled = Object.fromEntries(Object.keys(CATEGORY_PACKS).map(k=>[k,true]));
  }
}
function enabledItems(){
  const keys = Object.keys(CATEGORY_PACKS).filter(k => settings.packsEnabled[k]);
  const list = [];
  for(const k of keys) list.push(...CATEGORY_PACKS[k].items);
  if(list.length === 0){
    for(const k of Object.keys(CATEGORY_PACKS)) list.push(...CATEGORY_PACKS[k].items);
  }
  return list;
}
const rand = (a,b)=>Math.floor(Math.random()*(b-a+1))+a;
const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
function pickCategory(){ const items = enabledItems(); return items[rand(0, items.length-1)]; }

/* ===================== MULTI STATE ===================== */
let roomCode = null;
let myId = null;
let isHost = false;
let roomData = null; // snapshot data

function getOrCreateMyId(){
  const k = "wl_myId_v1";
  let v = localStorage.getItem(k);
  if(!v){
    v = "p_" + Math.random().toString(36).slice(2,10);
    localStorage.setItem(k, v);
  }
  return v;
}
function generateRoomCode(){
  const chars = "ABCDEFGHJKLMNPQRSTUVWXYZ23456789";
  let out = "";
  for(let i=0;i<4;i++) out += chars[Math.floor(Math.random()*chars.length)];
  return out;
}
function now(){ return Date.now(); }

/* ===================== DOM ===================== */
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

const turnTitle = document.getElementById("turnTitle");
const turnSub   = document.getElementById("turnSub");
const pairDiv   = document.getElementById("pair");

const btnSettings = document.getElementById("btnSettings");
const btn = document.getElementById("actionBtn");

const sliderWrap = document.getElementById("sliderWrap");
const needleSlider = document.getElementById("needleSlider");
const sliderVal = document.getElementById("sliderVal");

const legendWrap = document.getElementById("legendWrap");
const revealNote = document.getElementById("revealNote");

const scoresDiv = document.getElementById("scores");
const btnResetScores = document.getElementById("btnResetScores");

/* Multi DOM */
const btnHost = document.getElementById("btnHost");
const btnJoin = document.getElementById("btnJoin");
const multiBox = document.getElementById("multiBox");
const roomCodeInput = document.getElementById("roomCodeInput");
const playerNameInput = document.getElementById("playerNameInput");
const btnConfirmJoin = document.getElementById("btnConfirmJoin");
const roomInfo = document.getElementById("roomInfo");
const roomCodeLabel = document.getElementById("roomCodeLabel");
const lobbyPlayers = document.getElementById("lobbyPlayers");
const roomStatusLabel = document.getElementById("roomStatusLabel");
const roleLabel = document.getElementById("roleLabel");

/* Settings modal DOM */
const settingsOverlay = document.getElementById("settingsOverlay");
const btnCloseSettings = document.getElementById("btnCloseSettings");
const packsList = document.getElementById("packsList");
const btnSelectAll = document.getElementById("btnSelectAll");
const btnSelectNone = document.getElementById("btnSelectNone");
const btnSaveSettings = document.getElementById("btnSaveSettings");
const pointsToWinInput = document.getElementById("pointsToWinInput");

/* Winner modal DOM */
const winnerOverlay = document.getElementById("winnerOverlay");
const winnerTitle = document.getElementById("winnerTitle");
const winnerSub = document.getElementById("winnerSub");
const btnCloseWinner = document.getElementById("btnCloseWinner");
const btnContinue = document.getElementById("btnContinue");

/* ===================== DRAW ===================== */
function pctToAngle(pct){
  // 0% = gauche (PI), 100% = droite (0) -> demi-cercle haut
  return Math.PI - (pct/100) * Math.PI;
}
function drawBaseArc(cx,cy,r){
  ctx.save();
  ctx.strokeStyle="rgba(255,255,255,.18)";
  ctx.lineWidth=60;
  ctx.lineCap="round";
  ctx.beginPath();
  ctx.arc(cx,cy,r,Math.PI,0,false);
  ctx.stroke();
  ctx.restore();
}
function drawArcBand(cx,cy,r, centerPct, radiusPct, color, lw){
  const leftPct  = clamp(centerPct - radiusPct, 0, 100);
  const rightPct = clamp(centerPct + radiusPct, 0, 100);
  const aLeft  = pctToAngle(leftPct);
  const aRight = pctToAngle(rightPct);

  ctx.save();
  ctx.beginPath();
  ctx.rect(0, 0, 900, cy); // clip moitié haute
  ctx.clip();

  ctx.strokeStyle = color;
  ctx.lineWidth = lw;
  ctx.lineCap = "butt";
  ctx.beginPath();
  ctx.arc(cx, cy, r, aLeft, aRight, false);
  ctx.stroke();
  ctx.restore();
}
function drawScoringBands(cx, cy, r, secret){
  const ringR = r - 18;
  const lw = 40;
  drawArcBand(cx, cy, ringR, secret, Z_RED,    "rgba(239,68,68,.28)",  lw);
  drawArcBand(cx, cy, ringR, secret, Z_ORANGE, "rgba(245,158,11,.32)", lw);
  drawArcBand(cx, cy, ringR, secret, Z_GREEN,  "rgba(34,197,94,.36)",  lw);
}
function drawNeedle(pct, color, width, cx,cy,r){
  const a = pctToAngle(pct);
  const nx = cx + Math.cos(a)*r;
  const ny = cy - Math.sin(a)*r;

  ctx.save();
  ctx.lineCap="round";

  ctx.strokeStyle = "rgba(0,0,0,.55)";
  ctx.lineWidth = width + 3;
  ctx.beginPath();
  ctx.moveTo(cx,cy);
  ctx.lineTo(nx,ny);
  ctx.stroke();

  ctx.strokeStyle = color;
  ctx.lineWidth = width;
  ctx.beginPath();
  ctx.moveTo(cx,cy);
  ctx.lineTo(nx,ny);
  ctx.stroke();

  ctx.restore();
}
function drawDial({mode, secret, guesses, playersMap, psychicId, currentNeedle}){
  ctx.clearRect(0,0,900,520);
  const cx=450, cy=460, r=320;

  drawBaseArc(cx,cy,r);

  if(mode === "reveal"){
    drawScoringBands(cx,cy,r, secret);
  }

  ctx.save();
  ctx.fillStyle="rgba(255,255,255,.90)";
  ctx.beginPath();
  ctx.arc(cx,cy,12,0,Math.PI*2);
  ctx.fill();
  ctx.restore();

  if(mode === "psychic_word"){
    // on ne montre PAS le secret, juste un marqueur neutre
    drawNeedle(50, "rgba(255,255,255,.65)", 4, cx,cy,r);
  }

  if(mode === "team"){
    drawNeedle(currentNeedle, "rgba(255,255,255,.92)", 6, cx,cy,r);

    ctx.save();
    ctx.fillStyle="rgba(255,255,255,.88)";
    ctx.font="900 32px Arial";
    ctx.textAlign="center";
    ctx.fillText(String(currentNeedle), cx, 70);
    ctx.font="700 14px Arial";
    ctx.fillStyle="rgba(255,255,255,.60)";
    ctx.fillText("Ton placement", cx, 95);
    ctx.restore();
  }

  if(mode === "reveal"){
    drawNeedle(secret, "rgba(255,255,255,.95)", 11, cx,cy,r);

    for(const [pid, g] of Object.entries(guesses || {})){
      if(pid === psychicId) continue;
      const p = playersMap?.[pid];
      if(p && typeof g === "number"){
        drawNeedle(g, p.color || "#999", 5, cx,cy,r);
      }
    }

    const as = pctToAngle(secret);
    ctx.save();
    ctx.fillStyle = "#f97316";
    ctx.beginPath();
    ctx.arc(cx+Math.cos(as)*r, cy-Math.sin(as)*r, 7, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  }
}

/* ===================== UI HELPERS ===================== */
function setPair(category, word){
  if(!category && !word){
    pairDiv.innerHTML = `<span class="pill">—</span>`;
    return;
  }
  if(category && word){
    pairDiv.innerHTML = `<span class="pill">${category}</span><span class="pill">${word}</span>`;
    return;
  }
  pairDiv.innerHTML = `<span class="pill">${category || word}</span>`;
}

function openWinner(name, score, target){
  winnerTitle.textContent = "Victoire !";
  winnerSub.textContent = `${name} gagne avec ${score} points (objectif: ${target}).`;
  winnerOverlay.classList.add("show");
}
function closeWinner(){ winnerOverlay.classList.remove("show"); }

/* ===================== ROOM RENDER ===================== */
function renderLobby(playersMap, hostId){
  lobbyPlayers.innerHTML = "";
  const entries = Object.entries(playersMap || {});
  if(entries.length === 0){
    lobbyPlayers.innerHTML = `<div class="small">Personne dans la room.</div>`;
    return;
  }
  // tri par joinedAt si présent
  entries.sort((a,b)=> (a[1]?.joinedAt||0) - (b[1]?.joinedAt||0));

  for(const [pid, p] of entries){
    const line = document.createElement("div");
    line.className = "scoreline";
    line.innerHTML = `
      <div class="scoreLeft">
        <span class="colorDot" style="background:${p.color || "#999"}"></span>
        <span class="nameText">
          ${(p.name || pid)}
          ${pid === hostId ? " (Host)" : ""}
          ${pid === myId ? " (Toi)" : ""}
        </span>
      </div>
      <div class="scorePts">${p.score ?? 0} pts</div>
    `;
    lobbyPlayers.appendChild(line);
  }
}

function renderScores(playersMap, psychicId){
  scoresDiv.innerHTML = "";
  const entries = Object.entries(playersMap || {});
  entries.sort((a,b)=> (a[1]?.score||0) < (b[1]?.score||0) ? 1 : -1);

  for(const [pid, p] of entries){
    const line = document.createElement("div");
    line.className = "scoreline";
    line.innerHTML = `
      <div class="scoreLeft">
        <span class="colorDot" style="background:${p.color || "#999"}"></span>
        <span class="nameText">
          ${(p.name || pid)}${pid===psychicId ? " (Psychic)" : ""}
        </span>
      </div>
      <div class="scorePts">${p.score ?? 0} pts</div>
    `;
    scoresDiv.appendChild(line);
  }
}

/* ===================== ROOM LOGIC ===================== */
async function createRoom(hostName, hostColor){
  const code = generateRoomCode();
  const roomRef = doc(db, "rooms", code);

  const hostId = myId;

  await setDoc(roomRef, {
    hostId,
    pointsToWin: settings.pointsToWin || 20,
    packsEnabled: settings.packsEnabled || {},
    phase: "lobby",            // lobby | psychic_word | team | reveal
    psychicId: hostId,
    category: null,
    word: null,
    secret: null,
    guesses: {},
    order: [hostId],
    players: {
      [hostId]: { name: hostName, color: hostColor, score: 0, joinedAt: now() }
    },
    createdAt: now(),
    updatedAt: now()
  });

  return code;
}

async function joinRoom(code, playerName, playerColor){
  const roomRef = doc(db, "rooms", code);
  const snap = await getDoc(roomRef);
  if(!snap.exists()){
    alert("Room inexistante");
    return false;
  }

  const data = snap.data();
  const order = Array.isArray(data.order) ? data.order.slice() : [];
  if(!order.includes(myId)) order.push(myId);

  await updateDoc(roomRef, {
    [`players.${myId}`]: { name: playerName, color: playerColor, score: 0, joinedAt: now() },
    order: order,
    updatedAt: now()
  });

  return true;
}

function isMyTurnPsychic(d){
  return d && d.psychicId === myId;
}
function isRoomHost(d){
  return d && d.hostId === myId;
}

async function hostStartRound(){
  if(!roomCode) return;
  const roomRef = doc(db, "rooms", roomCode);
  const d = roomData;
  if(!d) return;

  const cat = pickCategory();
  const secret = rand(0,100);

  await updateDoc(roomRef, {
    phase: "psychic_word",
    category: cat,
    word: null,
    secret: secret,
    guesses: {}, // reset
    updatedAt: now()
  });
}

async function psychicSubmitWord(word){
  if(!roomCode) return;
  const roomRef = doc(db, "rooms", roomCode);

  const cleaned = (word || "").trim().slice(0,40);
  if(!cleaned){
    alert("Écris un mot avant de valider.");
    return;
  }

  // le psychic écrit le mot -> phase team
  await updateDoc(roomRef, {
    word: cleaned,
    phase: "team",
    updatedAt: now()
  });
}

async function playerSubmitGuess(val){
  if(!roomCode) return;
  const roomRef = doc(db, "rooms", roomCode);

  await updateDoc(roomRef, {
    [`guesses.${myId}`]: Number(val),
    updatedAt: now()
  });
}

function allTeamGuessed(d){
  const playersMap = d.players || {};
  const ids = Object.keys(playersMap);
  const psychicId = d.psychicId;
  const teamIds = ids.filter(id => id !== psychicId);
  const guesses = d.guesses || {};
  return teamIds.every(id => typeof guesses[id] === "number");
}

async function hostComputeRevealAndScore(){
  const d = roomData;
  if(!d || !roomCode) return;
  if(d.phase !== "team") return;
  if(!allTeamGuessed(d)) return;

  const roomRef = doc(db, "rooms", roomCode);
  const playersMap = d.players || {};
  const guesses = d.guesses || {};
  const secret = d.secret;

  // calc points pour chaque joueur non-psychic
  const updates = {};
  for(const [pid, p] of Object.entries(playersMap)){
    if(pid === d.psychicId) continue;
    const g = guesses[pid];
    if(typeof g !== "number") continue;
    const add = pointsForGuess(secret, g);
    const newScore = (p.score || 0) + add;
    updates[`players.${pid}.score`] = newScore;
  }

  // reveal
  updates["phase"] = "reveal";
  updates["updatedAt"] = now();

  await updateDoc(roomRef, updates);

  // check victory (host only)
  const target = Number(d.pointsToWin || 20);
  if(Number.isFinite(target) && target > 0){
    let bestId = null, bestScore = -1;
    for(const [pid, p] of Object.entries(playersMap)){
      const s = (updates[`players.${pid}.score`] != null) ? updates[`players.${pid}.score`] : (p.score || 0);
      if(s >= target && s > bestScore){
        bestScore = s;
        bestId = pid;
      }
    }
    if(bestId){
      const name = playersMap[bestId]?.name || bestId;
      // on ne stocke pas "winner" pour l'instant, on affiche côté client via snapshot après MAJ
      // (simple)
    }
  }
}

async function hostNextRound(){
  if(!roomCode) return;
  const d = roomData;
  if(!d) return;

  const order = Array.isArray(d.order) ? d.order : [];
  if(order.length < 2){
    alert("Il faut au moins 2 joueurs.");
    return;
  }

  const idx = Math.max(0, order.indexOf(d.psychicId));
  const nextPsychic = order[(idx + 1) % order.length];

  const roomRef = doc(db, "rooms", roomCode);

  await updateDoc(roomRef, {
    psychicId: nextPsychic,
    phase: "lobby",
    category: null,
    word: null,
    secret: null,
    guesses: {},
    updatedAt: now()
  });
}

/* ===================== LISTEN ===================== */
function listenRoom(code){
  const roomRef = doc(db, "rooms", code);
  onSnapshot(roomRef, async (snap)=>{
    if(!snap.exists()) return;
    roomData = snap.data();

    // render lobby UI
    roomCodeLabel.textContent = code;
    roomInfo.classList.remove("hidden");

    renderLobby(roomData.players || {}, roomData.hostId);
    renderScores(roomData.players || {}, roomData.psychicId);

    // role labels
    roomStatusLabel.textContent = roomData.phase || "—";
    roleLabel.textContent =
      (isRoomHost(roomData) ? "Tu es HOST." : "Tu es JOUEUR.")
      + " "
      + (isMyTurnPsychic(roomData) ? "Tu es PSYCHIC." : "");

    // Partie visuelle
    const phase = roomData.phase || "lobby";
    const category = roomData.category;
    const word = roomData.word;

    // affichage catégorie + mot pour tout le monde
    if(phase === "lobby"){
      setPair("En attente…", "Crée / rejoins une room");
      sliderWrap.classList.add("hidden");
      legendWrap.classList.add("hidden");
      revealNote.classList.add("hidden");
      drawDial({mode:"psychic_word", secret:50, guesses:{}, playersMap:{}, psychicId:roomData.psychicId, currentNeedle:50});
    } else if(phase === "psychic_word"){
      setPair(category || "Catégorie", isMyTurnPsychic(roomData) ? "Écris le mot…" : "En attente du Psychic…");
      sliderWrap.classList.add("hidden");
      legendWrap.classList.add("hidden");
      revealNote.classList.add("hidden");
      drawDial({mode:"psychic_word", secret:50, guesses:{}, playersMap:{}, psychicId:roomData.psychicId, currentNeedle:50});
    } else if(phase === "team"){
      setPair(category || "Catégorie", word || "Mot");
      legendWrap.classList.add("hidden");
      revealNote.classList.add("hidden");
      // le slider seulement pour NON-psychic
      sliderWrap.classList.toggle("hidden", isMyTurnPsychic(roomData));
      drawDial({
        mode:"team",
        secret:roomData.secret,
        guesses:roomData.guesses || {},
        playersMap:roomData.players || {},
        psychicId:roomData.psychicId,
        currentNeedle: currentNeedle
      });

      // si host: check auto reveal
      if(isRoomHost(roomData)){
        await hostComputeRevealAndScore();
      }
    } else if(phase === "reveal"){
      setPair(category || "Catégorie", word || "Mot");
      sliderWrap.classList.add("hidden");
      legendWrap.classList.remove("hidden");
      revealNote.classList.remove("hidden");
      drawDial({
        mode:"reveal",
        secret:roomData.secret,
        guesses:roomData.guesses || {},
        playersMap:roomData.players || {},
        psychicId:roomData.psychicId,
        currentNeedle:50
      });

      // victoire (affichage client)
      const target = Number(roomData.pointsToWin || 20);
      if(Number.isFinite(target) && target > 0){
        let best = null;
        for(const [pid, p] of Object.entries(roomData.players || {})){
          const s = p.score || 0;
          if(s >= target && (!best || s > best.score)){
            best = {pid, name:p.name||pid, score:s};
          }
        }
        if(best){
          openWinner(best.name, best.score, target);
        }
      }
    }

    // Action button
    updateActionButtonFromRoom();
  });
}

/* ===================== ACTION BUTTON (multi) ===================== */
function updateActionButtonFromRoom(){
  const d = roomData;
  if(!d){
    btn.textContent = "—";
    btn.onclick = null;
    return;
  }

  const phase = d.phase || "lobby";

  // lobby
  if(phase === "lobby"){
    if(isRoomHost(d)){
      btn.textContent = "Lancer la manche";
      btn.onclick = hostStartRound;
    }else{
      btn.textContent = "En attente (host lance)";
      btn.onclick = null;
    }
    return;
  }

  // psychic_word
  if(phase === "psychic_word"){
    if(isMyTurnPsychic(d)){
      btn.textContent = "Valider le mot";
      btn.onclick = async ()=>{
        const w = prompt("Mot choisi par le Psychic (visible à tous) :", "");
        if(w == null) return;
        await psychicSubmitWord(w);
      };
    } else {
      btn.textContent = "En attente du Psychic…";
      btn.onclick = null;
    }
    return;
  }

  // team
  if(phase === "team"){
    if(isMyTurnPsychic(d)){
      btn.textContent = "Psychic : observe";
      btn.onclick = null;
    } else {
      const already = d.guesses && typeof d.guesses[myId] === "number";
      btn.textContent = already ? "Placement envoyé" : "Valider mon placement";
      btn.onclick = async ()=>{
        if(already) return;
        await playerSubmitGuess(currentNeedle);
      };
    }
    return;
  }

  // reveal
  if(phase === "reveal"){
    if(isRoomHost(d)){
      btn.textContent = "Manche suivante";
      btn.onclick = hostNextRound;
    } else {
      btn.textContent = "En attente (host)";
      btn.onclick = null;
    }
    return;
  }
}

/* ===================== INPUTS: CANVAS DRAG + SLIDER ===================== */
let currentNeedle = 50;

function syncSlider(){
  needleSlider.value = String(currentNeedle);
  sliderVal.textContent = String(currentNeedle);
}

function pointerToPct(ev){
  const rect = canvas.getBoundingClientRect();
  const x = clamp((ev.clientX - rect.left) / rect.width, 0, 1);
  return Math.round(x * 100);
}

let dragging = false;
canvas.addEventListener("pointerdown", (e)=>{
  // uniquement si phase team ET si pas psychic
  if(!roomData || roomData.phase !== "team") return;
  if(isMyTurnPsychic(roomData)) return;

  dragging = true;
  canvas.setPointerCapture(e.pointerId);
  currentNeedle = pointerToPct(e);
  syncSlider();
  drawDial({
    mode:"team",
    secret:roomData.secret,
    guesses:roomData.guesses || {},
    playersMap:roomData.players || {},
    psychicId:roomData.psychicId,
    currentNeedle
  });
});

canvas.addEventListener("pointermove", (e)=>{
  if(!dragging) return;
  if(!roomData || roomData.phase !== "team") return;
  if(isMyTurnPsychic(roomData)) return;

  currentNeedle = pointerToPct(e);
  syncSlider();
  drawDial({
    mode:"team",
    secret:roomData.secret,
    guesses:roomData.guesses || {},
    playersMap:roomData.players || {},
    psychicId:roomData.psychicId,
    currentNeedle
  });
});

canvas.addEventListener("pointerup", ()=> dragging=false);
canvas.addEventListener("pointercancel", ()=> dragging=false);

needleSlider.addEventListener("input", ()=>{
  if(!roomData || roomData.phase !== "team") return;
  if(isMyTurnPsychic(roomData)) return;

  currentNeedle = Number(needleSlider.value);
  sliderVal.textContent = String(currentNeedle);
  drawDial({
    mode:"team",
    secret:roomData.secret,
    guesses:roomData.guesses || {},
    playersMap:roomData.players || {},
    psychicId:roomData.psychicId,
    currentNeedle
  });
});

/* ===================== SETTINGS MODAL ===================== */
function openSettings(){
  settingsOverlay.classList.add("show");
  renderSettingsUI();
}
function closeSettings(){ settingsOverlay.classList.remove("show"); }
btnSettings.onclick = openSettings;
btnCloseSettings.onclick = closeSettings;

function renderSettingsUI(){
  pointsToWinInput.value = String(settings.pointsToWin || 20);
  packsList.innerHTML = "";

  for(const [key, pack] of Object.entries(CATEGORY_PACKS)){
    const row = document.createElement("div");
    row.className = "scoreline";
    row.style.justifyContent = "space-between";

    const left = document.createElement("div");
    left.className = "scoreLeft";
    left.innerHTML = `<span class="nameText">${pack.label}</span>`;

    const right = document.createElement("div");
    right.style.display = "flex";
    right.style.alignItems = "center";
    right.style.gap = "10px";

    const count = document.createElement("span");
    count.className = "badge";
    count.textContent = `${pack.items.length} mots`;

    const checkbox = document.createElement("input");
    checkbox.type = "checkbox";
    checkbox.checked = !!settings.packsEnabled[key];
    checkbox.onchange = ()=>{ settings.packsEnabled[key] = checkbox.checked; };

    right.appendChild(count);
    right.appendChild(checkbox);

    row.appendChild(left);
    row.appendChild(right);
    packsList.appendChild(row);
  }
}

btnSelectAll.onclick = ()=>{
  for(const k of Object.keys(CATEGORY_PACKS)) settings.packsEnabled[k] = true;
  renderSettingsUI();
};
btnSelectNone.onclick = ()=>{
  for(const k of Object.keys(CATEGORY_PACKS)) settings.packsEnabled[k] = false;
  renderSettingsUI();
};

btnSaveSettings.onclick = async ()=>{
  const v = parseInt((pointsToWinInput.value || "").trim(), 10);
  if(!Number.isNaN(v) && v >= 1 && v <= 999){
    settings.pointsToWin = v;
  }
  saveSettings();
  closeSettings();

  // si tu es host et que tu es déjà en room, on pousse aussi les settings dans la room
  if(roomCode && roomData && isRoomHost(roomData)){
    const roomRef = doc(db, "rooms", roomCode);
    await updateDoc(roomRef, {
      pointsToWin: settings.pointsToWin,
      packsEnabled: settings.packsEnabled,
      updatedAt: now()
    });
  }
};

/* ===================== WINNER MODAL ===================== */
btnCloseWinner.onclick = closeWinner;
btnContinue.onclick = closeWinner;

/* ===================== RESET SCORES (HOST ONLY) ===================== */
btnResetScores.onclick = async ()=>{
  if(!roomCode || !roomData) return;
  if(!isRoomHost(roomData)){
    alert("Seul le host peut reset les scores.");
    return;
  }
  const roomRef = doc(db, "rooms", roomCode);
  const updates = {};
  for(const [pid] of Object.entries(roomData.players || {})){
    updates[`players.${pid}.score`] = 0;
  }
  updates.updatedAt = now();
  await updateDoc(roomRef, updates);
  closeWinner();
};

/* ===================== MULTI UI ===================== */
btnJoin.onclick = ()=> multiBox.classList.toggle("hidden");

btnHost.onclick = async ()=>{
  try{
    myId = getOrCreateMyId();
    isHost = true;

    const name = (prompt("Ton pseudo (host) ?", "Host") || "Host").slice(0,14);
    const color = COLOR_CHOICES[0].value;

    const code = await createRoom(name, color);
    roomCode = code;

    alert("Code à partager : " + code);
    listenRoom(code);
  }catch(e){
    alert("Erreur host: " + (e?.message || e));
    console.error(e);
  }
};

btnConfirmJoin.onclick = async ()=>{
  try{
    myId = getOrCreateMyId();
    isHost = false;

    const code = (roomCodeInput.value || "").trim().toUpperCase();
    const name = ((playerNameInput.value || "").trim() || "Joueur").slice(0,14);
    const color = COLOR_CHOICES[rand(0, COLOR_CHOICES.length-1)].value;

    if(code.length !== 4){
      alert("Le code doit faire 4 caractères.");
      return;
    }

    const ok = await joinRoom(code, name, color);
    if(!ok) return;

    roomCode = code;
    listenRoom(code);
  }catch(e){
    alert("Erreur join: " + (e?.message || e));
    console.error(e);
  }
};

/* ===================== INIT ===================== */
loadSettings();

// état initial
setPair(null, null);
sliderWrap.classList.add("hidden");
legendWrap.classList.add("hidden");
revealNote.classList.add("hidden");
drawDial({mode:"psychic_word", secret:50, guesses:{}, playersMap:{}, psychicId:"", currentNeedle:50});
btn.textContent = "Crée ou rejoins une room";
btn.onclick = null;
syncSlider();
</script>
</body>
</html>
